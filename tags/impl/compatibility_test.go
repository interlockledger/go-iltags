/*
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, InterlockLedger Network
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package impl

import (
	"bytes"
	"fmt"
	"testing"

	. "github.com/interlockledger/go-iltags/tags"
	"github.com/stretchr/testify/assert"
)

// This file contains a few serialization/deserialization tests used to ensure
// compatibility with the defined standard

var testTagFactory = NewStandardTagFactory(false)

func TestNullTagReference(t *testing.T) {

	serialized := []byte{0x00}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_NULL_TAG_ID, tag.Id())

	assert.IsType(t, &NullTag{}, tag)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestBoolTagReference(t *testing.T) {

	serialized := []byte{0x01,
		0x01}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BOOL_TAG_ID, tag.Id())
	assert.IsType(t, &BoolTag{}, tag)
	assert.True(t, tag.(*BoolTag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestInt8TagReference(t *testing.T) {

	serialized := []byte{0x02,
		0xFE}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_INT8_TAG_ID, tag.Id())
	assert.IsType(t, &Int8Tag{}, tag)
	assert.Equal(t, int8(-2), tag.(*Int8Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestUInt8TagReference(t *testing.T) {

	serialized := []byte{0x03,
		0xFE}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_UINT8_TAG_ID, tag.Id())
	assert.IsType(t, &UInt8Tag{}, tag)
	assert.Equal(t, uint8(0xFE), tag.(*UInt8Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestInt16TagReference(t *testing.T) {

	serialized := []byte{0x04,
		0xFE, 0xDC}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_INT16_TAG_ID, tag.Id())
	assert.IsType(t, &Int16Tag{}, tag)
	assert.Equal(t, int16(-292), tag.(*Int16Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestUInt16TagReference(t *testing.T) {

	serialized := []byte{0x05,
		0xFE, 0xDC}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_UINT16_TAG_ID, tag.Id())
	assert.IsType(t, &UInt16Tag{}, tag)
	assert.Equal(t, uint16(0xFEDC), tag.(*UInt16Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestInt32TagReference(t *testing.T) {

	serialized := []byte{0x06,
		0xFE, 0xDC, 0xBA, 0x98}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_INT32_TAG_ID, tag.Id())
	assert.IsType(t, &Int32Tag{}, tag)
	assert.Equal(t, int32(-19088744), tag.(*Int32Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestUInt32TagReference(t *testing.T) {

	serialized := []byte{0x07,
		0xFE, 0xDC, 0xBA, 0x98}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_UINT32_TAG_ID, tag.Id())
	assert.IsType(t, &UInt32Tag{}, tag)
	assert.Equal(t, uint32(0xFEDCBA98), tag.(*UInt32Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestInt64TagReference(t *testing.T) {

	serialized := []byte{0x08,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_INT64_TAG_ID, tag.Id())
	assert.IsType(t, &Int64Tag{}, tag)
	assert.Equal(t, int64(-81985529216486896), tag.(*Int64Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestUInt64TagReference(t *testing.T) {

	serialized := []byte{0x09,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_UINT64_TAG_ID, tag.Id())
	assert.IsType(t, &UInt64Tag{}, tag)
	assert.Equal(t, uint64(0xFEDCBA9876543210), tag.(*UInt64Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestILIntTagReference(t *testing.T) {

	serialized := []byte{0x0A,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILINT_TAG_ID, tag.Id())
	assert.IsType(t, &ILIntTag{}, tag)
	assert.Equal(t, uint64(0xdcba9876543308), tag.(*ILIntTag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestFloat32TagReference(t *testing.T) {

	serialized := []byte{0x0B,
		0xFE, 0xDC, 0xBA, 0x98}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BIN32_TAG_ID, tag.Id())
	assert.IsType(t, &Float32Tag{}, tag)
	assert.Equal(t, float32(-1.466995e+38), tag.(*Float32Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestFloat64TagReference(t *testing.T) {

	serialized := []byte{0x0C,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BIN64_TAG_ID, tag.Id())
	assert.IsType(t, &Float64Tag{}, tag)
	assert.Equal(t, float64(-1.2313300687736946e+303), tag.(*Float64Tag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestFloat128TagReference(t *testing.T) {

	serialized := []byte{0x0D,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BIN128_TAG_ID, tag.Id())
	assert.IsType(t, &Float128Tag{}, tag)
	assert.Equal(t, serialized[1:], tag.(*Float128Tag).Payload[:])
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestSignedILIntTagReference(t *testing.T) {

	serialized := []byte{0x0E, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x11}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_SIGNED_ILINT_TAG_ID, tag.Id())
	assert.IsType(t, &SignedILIntTag{}, tag)
	assert.Equal(t, int64(-31064829429684613), tag.(*SignedILIntTag).Payload)
	w := bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestBytesTagReference(t *testing.T) {

	serialized := []byte{
		0x10, // ID
		0x00, // Size
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BYTES_TAG_ID, tag.Id())
	assert.IsType(t, &BytesTag{}, tag)
	assert.Equal(t, []byte{}, tag.(*BytesTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x10,       // ID
		0xF8, 0x08, // Size
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BYTES_TAG_ID, tag.Id())
	assert.IsType(t, &BytesTag{}, tag)
	assert.Equal(t, serialized[3:], tag.(*BytesTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestStringTagReference(t *testing.T) {

	serialized := []byte{
		0x11, // ID
		0x00, // Size
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_TAG_ID, tag.Id())
	assert.IsType(t, &StringTag{}, tag)
	assert.Equal(t, "", tag.(*StringTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x11, // ID
		0x25, // Size
		0x41, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x61,
		0x20, 0xc3, 0xa9, 0x20, 0x61, 0x20, 0x69, 0x6e,
		0x69, 0x6d, 0x69, 0x67, 0x61, 0x20, 0x64, 0x61,
		0x20, 0x70, 0x65, 0x72, 0x66, 0x65, 0x69, 0xc3,
		0xa7, 0xc3, 0xa3, 0x6f, 0x2e}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_TAG_ID, tag.Id())
	assert.IsType(t, &StringTag{}, tag)
	assert.Equal(t, "A pressa é a inimiga da perfeição.", tag.(*StringTag).Payload)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestBigIntTagReference(t *testing.T) {

	serialized := []byte{
		0x12, // ID
		0x01, // Size
		0x23, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BINT_TAG_ID, tag.Id())
	assert.IsType(t, &BigIntTag{}, tag)
	assert.Equal(t, []byte{0x23}, tag.(*BigIntTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x12,       // ID
		0xF8, 0x08, // Size
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BINT_TAG_ID, tag.Id())
	assert.IsType(t, &BigIntTag{}, tag)
	assert.Equal(t, serialized[3:], tag.(*BigIntTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x12, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestBigDecTagReference(t *testing.T) {

	serialized := []byte{
		0x13, // ID
		0x05, // Size
		0x23, 0x45, 0x67, 0x89, 0xAB}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BDEC_TAG_ID, tag.Id())
	assert.IsType(t, &BigDecTag{}, tag)
	assert.Equal(t, []byte{0x23}, tag.(*BigDecTag).Payload)
	assert.Equal(t, int32(0x456789AB), tag.(*BigDecTag).Scale)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x13,       // ID
		0xF8, 0x08, // Size
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_BDEC_TAG_ID, tag.Id())
	assert.IsType(t, &BigDecTag{}, tag)
	assert.Equal(t, serialized[3:len(serialized)-4], tag.(*BigDecTag).Payload)
	assert.Equal(t, int32(-1985229329), tag.(*BigDecTag).Scale)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x13, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestILIntArrayTagReference(t *testing.T) {

	serialized := []byte{
		0x14, // ID
		0x01, // Size
		0x00, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILINTARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILIntArrayTag{}, tag)
	assert.Equal(t, []uint64{}, tag.(*ILIntArrayTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x14, // ID
		0x37, // Size
		0x0A,
		0xF7,
		0xF8, 0x00,
		0xF9, 0x01, 0x23,
		0xFA, 0x01, 0x23, 0x45,
		0xFB, 0x01, 0x23, 0x45, 0x67,
		0xFC, 0x01, 0x23, 0x45, 0x67, 0x89,
		0xFD, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB,
		0xFE, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD,
		0xFF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILINTARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILIntArrayTag{}, tag)
	assert.Equal(t, []uint64{
		0xf7,
		0xf8,
		0x21b,
		0x1243d,
		0x123465f,
		0x123456881,
		0x12345678aa3,
		0x123456789acc5,
		0x123456789abcee7,
		0xffffffffffffffff}, tag.(*ILIntArrayTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	// Long zeroes
	serialized = append(
		[]byte{
			0x14,       // ID
			0xF8, 0x0A, // Size
			0xF8, 0x08, // Count
		},
		make([]byte, 256)...)
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILINTARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILIntArrayTag{}, tag)
	assert.Equal(t, make([]uint64, 256), tag.(*ILIntArrayTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x14, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestILTagArrayTagReference(t *testing.T) {

	serialized := []byte{
		0x15, // ID
		0x01, // Size
		0x00, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagArrayTag{}, tag)
	assert.Equal(t, []ILTag{}, tag.(*ILTagArrayTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x15,       // ID
		0x07,       // Size
		0x03,       // Count
		0x00,       // NullTag
		0x01, 0x00, // Bool tag
		0x04, 0x00, 0x00, // Int16 tag
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagArrayTag{}, tag)
	exp := []ILTag{
		NewStdNullTag(),
		NewStdBoolTag(),
		NewStdInt16Tag()}
	assert.Equal(t, exp, tag.(*ILTagArrayTag).Payload)

	serialized = append(
		[]byte{
			0x15,       // ID
			0xF8, 0x0A, // Size
			0xF8, 0x08, // Count
		},
		make([]byte, 256)...)
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGARRAY_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagArrayTag{}, tag)
	exp = make([]ILTag, 256)
	for i := 0; i < 256; i++ {
		exp[i] = NewStdNullTag()
	}
	assert.Equal(t, exp, tag.(*ILTagArrayTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x15, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestILTagSequenceTagReference(t *testing.T) {

	serialized := []byte{
		0x16, // ID
		0x00, // Size
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGSEQ_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagSequenceTag{}, tag)
	assert.Equal(t, []ILTag{}, tag.(*ILTagSequenceTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x16,       // ID
		0x06,       // Size
		0x00,       // NullTag
		0x01, 0x00, // Bool tag
		0x04, 0x00, 0x00, // Int16 tag
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGSEQ_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagSequenceTag{}, tag)
	exp := []ILTag{
		NewStdNullTag(),
		NewStdBoolTag(),
		NewStdInt16Tag()}
	assert.Equal(t, exp, tag.(*ILTagSequenceTag).Payload)

	serialized = append(
		[]byte{
			0x16,       // ID
			0xF8, 0x08, // Size
		},
		make([]byte, 256)...)
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_ILTAGSEQ_TAG_ID, tag.Id())
	assert.IsType(t, &ILTagSequenceTag{}, tag)
	exp = make([]ILTag, 256)
	for i := 0; i < 256; i++ {
		exp[i] = NewStdNullTag()
	}
	assert.Equal(t, exp, tag.(*ILTagSequenceTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())
}

func TestRangeTagReference(t *testing.T) {

	serialized := []byte{
		0x17, // ID
		0x03, // Size
		0x00,
		0x00, 0x00}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_RANGE_TAG_ID, tag.Id())
	assert.IsType(t, &RangeTag{}, tag)
	assert.Equal(t, uint64(0), tag.(*RangeTag).Start)
	assert.Equal(t, uint16(0), tag.(*RangeTag).Count)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x17, // ID
		0x04, // Size
		0xF8, 0x08,
		0xFE, 0xDC}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_RANGE_TAG_ID, tag.Id())
	assert.IsType(t, &RangeTag{}, tag)
	assert.Equal(t, uint64(256), tag.(*RangeTag).Start)
	assert.Equal(t, uint16(0xFEDC), tag.(*RangeTag).Count)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x17, // ID
		0x0A, // Size
		0xFE, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD,
		0xFE, 0xDC}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_RANGE_TAG_ID, tag.Id())
	assert.IsType(t, &RangeTag{}, tag)
	assert.Equal(t, uint64(0x123456789ACC5), tag.(*RangeTag).Start)
	assert.Equal(t, uint16(0xFEDC), tag.(*RangeTag).Count)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x17, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestVersionTagReference(t *testing.T) {

	serialized := []byte{
		0x18, // ID
		0x10, // Size
		0xFE, 0xDC, 0xBA, 0x98,
		0x76, 0x54, 0x32, 0x10,
		0x01, 0x23, 0x45, 0x67,
		0x89, 0xAB, 0xCD, 0xEF}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_VERSION_TAG_ID, tag.Id())
	assert.IsType(t, &VersionTag{}, tag)
	assert.Equal(t, int32(-19088744), tag.(*VersionTag).Major)
	assert.Equal(t, int32(1985229328), tag.(*VersionTag).Minor)
	assert.Equal(t, int32(19088743), tag.(*VersionTag).Revision)
	assert.Equal(t, int32(-1985229329), tag.(*VersionTag).Build)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x18, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestOIDTagReference(t *testing.T) {

	serialized := []byte{
		0x19, // ID
		0x01, // Size
		0x00, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_OID_TAG_ID, tag.Id())
	assert.IsType(t, &OIDTag{}, tag)
	assert.Equal(t, []uint64{}, tag.(*OIDTag).Payload)
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x19, // ID
		0x37, // Size
		0x0A,
		0xF7,
		0xF8, 0x00,
		0xF9, 0x01, 0x23,
		0xFA, 0x01, 0x23, 0x45,
		0xFB, 0x01, 0x23, 0x45, 0x67,
		0xFC, 0x01, 0x23, 0x45, 0x67, 0x89,
		0xFD, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB,
		0xFE, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD,
		0xFF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_OID_TAG_ID, tag.Id())
	assert.IsType(t, &OIDTag{}, tag)
	assert.Equal(t, []uint64{
		0xf7,
		0xf8,
		0x21b,
		0x1243d,
		0x123465f,
		0x123456881,
		0x12345678aa3,
		0x123456789acc5,
		0x123456789abcee7,
		0xffffffffffffffff}, tag.(*OIDTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	// Long zeroes
	serialized = append(
		[]byte{
			0x19,       // ID
			0xF8, 0x0A, // Size
			0xF8, 0x08, // Count
		},
		make([]byte, 256)...)
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_OID_TAG_ID, tag.Id())
	assert.IsType(t, &OIDTag{}, tag)
	assert.Equal(t, make([]uint64, 256), tag.(*OIDTag).Payload)
	w = bytes.NewBuffer(nil)
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x19, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestDictionaryTagReference(t *testing.T) {

	serialized := []byte{
		0x1E, // ID
		0x01, // Size
		0x00, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &DictionaryTag{}, tag)
	assert.Equal(t, 0, tag.(*DictionaryTag).Map.Size())
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1E,       // ID
		0x04,       // Size
		0x01,       // Count
		0x11, 0x00, // Key 0
		0x00, // Value 0
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &DictionaryTag{}, tag)
	assert.Equal(t, []string{""}, tag.(*DictionaryTag).Map.Keys())
	tv, ok := tag.(*DictionaryTag).Map.Get("")
	assert.True(t, ok)
	assert.Equal(t, NewStdNullTag(), tv)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1E,             // ID
		0x0A,             // Size
		0x02,             // Count
		0x11, 0x01, 0x31, // Key 0
		0x00,             // Value 0
		0x11, 0x01, 0x30, // Key 1
		0x01, 0x00, // Value 1
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &DictionaryTag{}, tag)
	assert.Equal(t, []string{"1", "0"}, tag.(*DictionaryTag).Map.Keys())
	tv, ok = tag.(*DictionaryTag).Map.Get("1")
	assert.True(t, ok)
	assert.Equal(t, NewStdNullTag(), tv)
	tv, ok = tag.(*DictionaryTag).Map.Get("0")
	assert.True(t, ok)
	assert.Equal(t, NewStdBoolTag(), tv)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1E,             // ID
		0xF9, 0x05, 0x0A, // Size
		0xF8, 0x08, // Count
		0x11, 0x02, 0x46, 0x46, 0x03, 0x00, 0x11, 0x02,
		0x46, 0x45, 0x03, 0x01, 0x11, 0x02, 0x46, 0x44,
		0x03, 0x02, 0x11, 0x02, 0x46, 0x43, 0x03, 0x03,
		0x11, 0x02, 0x46, 0x42, 0x03, 0x04, 0x11, 0x02,
		0x46, 0x41, 0x03, 0x05, 0x11, 0x02, 0x46, 0x39,
		0x03, 0x06, 0x11, 0x02, 0x46, 0x38, 0x03, 0x07,
		0x11, 0x02, 0x46, 0x37, 0x03, 0x08, 0x11, 0x02,
		0x46, 0x36, 0x03, 0x09, 0x11, 0x02, 0x46, 0x35,
		0x03, 0x0A, 0x11, 0x02, 0x46, 0x34, 0x03, 0x0B,
		0x11, 0x02, 0x46, 0x33, 0x03, 0x0C, 0x11, 0x02,
		0x46, 0x32, 0x03, 0x0D, 0x11, 0x02, 0x46, 0x31,
		0x03, 0x0E, 0x11, 0x02, 0x46, 0x30, 0x03, 0x0F,
		0x11, 0x02, 0x45, 0x46, 0x03, 0x10, 0x11, 0x02,
		0x45, 0x45, 0x03, 0x11, 0x11, 0x02, 0x45, 0x44,
		0x03, 0x12, 0x11, 0x02, 0x45, 0x43, 0x03, 0x13,
		0x11, 0x02, 0x45, 0x42, 0x03, 0x14, 0x11, 0x02,
		0x45, 0x41, 0x03, 0x15, 0x11, 0x02, 0x45, 0x39,
		0x03, 0x16, 0x11, 0x02, 0x45, 0x38, 0x03, 0x17,
		0x11, 0x02, 0x45, 0x37, 0x03, 0x18, 0x11, 0x02,
		0x45, 0x36, 0x03, 0x19, 0x11, 0x02, 0x45, 0x35,
		0x03, 0x1A, 0x11, 0x02, 0x45, 0x34, 0x03, 0x1B,
		0x11, 0x02, 0x45, 0x33, 0x03, 0x1C, 0x11, 0x02,
		0x45, 0x32, 0x03, 0x1D, 0x11, 0x02, 0x45, 0x31,
		0x03, 0x1E, 0x11, 0x02, 0x45, 0x30, 0x03, 0x1F,
		0x11, 0x02, 0x44, 0x46, 0x03, 0x20, 0x11, 0x02,
		0x44, 0x45, 0x03, 0x21, 0x11, 0x02, 0x44, 0x44,
		0x03, 0x22, 0x11, 0x02, 0x44, 0x43, 0x03, 0x23,
		0x11, 0x02, 0x44, 0x42, 0x03, 0x24, 0x11, 0x02,
		0x44, 0x41, 0x03, 0x25, 0x11, 0x02, 0x44, 0x39,
		0x03, 0x26, 0x11, 0x02, 0x44, 0x38, 0x03, 0x27,
		0x11, 0x02, 0x44, 0x37, 0x03, 0x28, 0x11, 0x02,
		0x44, 0x36, 0x03, 0x29, 0x11, 0x02, 0x44, 0x35,
		0x03, 0x2A, 0x11, 0x02, 0x44, 0x34, 0x03, 0x2B,
		0x11, 0x02, 0x44, 0x33, 0x03, 0x2C, 0x11, 0x02,
		0x44, 0x32, 0x03, 0x2D, 0x11, 0x02, 0x44, 0x31,
		0x03, 0x2E, 0x11, 0x02, 0x44, 0x30, 0x03, 0x2F,
		0x11, 0x02, 0x43, 0x46, 0x03, 0x30, 0x11, 0x02,
		0x43, 0x45, 0x03, 0x31, 0x11, 0x02, 0x43, 0x44,
		0x03, 0x32, 0x11, 0x02, 0x43, 0x43, 0x03, 0x33,
		0x11, 0x02, 0x43, 0x42, 0x03, 0x34, 0x11, 0x02,
		0x43, 0x41, 0x03, 0x35, 0x11, 0x02, 0x43, 0x39,
		0x03, 0x36, 0x11, 0x02, 0x43, 0x38, 0x03, 0x37,
		0x11, 0x02, 0x43, 0x37, 0x03, 0x38, 0x11, 0x02,
		0x43, 0x36, 0x03, 0x39, 0x11, 0x02, 0x43, 0x35,
		0x03, 0x3A, 0x11, 0x02, 0x43, 0x34, 0x03, 0x3B,
		0x11, 0x02, 0x43, 0x33, 0x03, 0x3C, 0x11, 0x02,
		0x43, 0x32, 0x03, 0x3D, 0x11, 0x02, 0x43, 0x31,
		0x03, 0x3E, 0x11, 0x02, 0x43, 0x30, 0x03, 0x3F,
		0x11, 0x02, 0x42, 0x46, 0x03, 0x40, 0x11, 0x02,
		0x42, 0x45, 0x03, 0x41, 0x11, 0x02, 0x42, 0x44,
		0x03, 0x42, 0x11, 0x02, 0x42, 0x43, 0x03, 0x43,
		0x11, 0x02, 0x42, 0x42, 0x03, 0x44, 0x11, 0x02,
		0x42, 0x41, 0x03, 0x45, 0x11, 0x02, 0x42, 0x39,
		0x03, 0x46, 0x11, 0x02, 0x42, 0x38, 0x03, 0x47,
		0x11, 0x02, 0x42, 0x37, 0x03, 0x48, 0x11, 0x02,
		0x42, 0x36, 0x03, 0x49, 0x11, 0x02, 0x42, 0x35,
		0x03, 0x4A, 0x11, 0x02, 0x42, 0x34, 0x03, 0x4B,
		0x11, 0x02, 0x42, 0x33, 0x03, 0x4C, 0x11, 0x02,
		0x42, 0x32, 0x03, 0x4D, 0x11, 0x02, 0x42, 0x31,
		0x03, 0x4E, 0x11, 0x02, 0x42, 0x30, 0x03, 0x4F,
		0x11, 0x02, 0x41, 0x46, 0x03, 0x50, 0x11, 0x02,
		0x41, 0x45, 0x03, 0x51, 0x11, 0x02, 0x41, 0x44,
		0x03, 0x52, 0x11, 0x02, 0x41, 0x43, 0x03, 0x53,
		0x11, 0x02, 0x41, 0x42, 0x03, 0x54, 0x11, 0x02,
		0x41, 0x41, 0x03, 0x55, 0x11, 0x02, 0x41, 0x39,
		0x03, 0x56, 0x11, 0x02, 0x41, 0x38, 0x03, 0x57,
		0x11, 0x02, 0x41, 0x37, 0x03, 0x58, 0x11, 0x02,
		0x41, 0x36, 0x03, 0x59, 0x11, 0x02, 0x41, 0x35,
		0x03, 0x5A, 0x11, 0x02, 0x41, 0x34, 0x03, 0x5B,
		0x11, 0x02, 0x41, 0x33, 0x03, 0x5C, 0x11, 0x02,
		0x41, 0x32, 0x03, 0x5D, 0x11, 0x02, 0x41, 0x31,
		0x03, 0x5E, 0x11, 0x02, 0x41, 0x30, 0x03, 0x5F,
		0x11, 0x02, 0x39, 0x46, 0x03, 0x60, 0x11, 0x02,
		0x39, 0x45, 0x03, 0x61, 0x11, 0x02, 0x39, 0x44,
		0x03, 0x62, 0x11, 0x02, 0x39, 0x43, 0x03, 0x63,
		0x11, 0x02, 0x39, 0x42, 0x03, 0x64, 0x11, 0x02,
		0x39, 0x41, 0x03, 0x65, 0x11, 0x02, 0x39, 0x39,
		0x03, 0x66, 0x11, 0x02, 0x39, 0x38, 0x03, 0x67,
		0x11, 0x02, 0x39, 0x37, 0x03, 0x68, 0x11, 0x02,
		0x39, 0x36, 0x03, 0x69, 0x11, 0x02, 0x39, 0x35,
		0x03, 0x6A, 0x11, 0x02, 0x39, 0x34, 0x03, 0x6B,
		0x11, 0x02, 0x39, 0x33, 0x03, 0x6C, 0x11, 0x02,
		0x39, 0x32, 0x03, 0x6D, 0x11, 0x02, 0x39, 0x31,
		0x03, 0x6E, 0x11, 0x02, 0x39, 0x30, 0x03, 0x6F,
		0x11, 0x02, 0x38, 0x46, 0x03, 0x70, 0x11, 0x02,
		0x38, 0x45, 0x03, 0x71, 0x11, 0x02, 0x38, 0x44,
		0x03, 0x72, 0x11, 0x02, 0x38, 0x43, 0x03, 0x73,
		0x11, 0x02, 0x38, 0x42, 0x03, 0x74, 0x11, 0x02,
		0x38, 0x41, 0x03, 0x75, 0x11, 0x02, 0x38, 0x39,
		0x03, 0x76, 0x11, 0x02, 0x38, 0x38, 0x03, 0x77,
		0x11, 0x02, 0x38, 0x37, 0x03, 0x78, 0x11, 0x02,
		0x38, 0x36, 0x03, 0x79, 0x11, 0x02, 0x38, 0x35,
		0x03, 0x7A, 0x11, 0x02, 0x38, 0x34, 0x03, 0x7B,
		0x11, 0x02, 0x38, 0x33, 0x03, 0x7C, 0x11, 0x02,
		0x38, 0x32, 0x03, 0x7D, 0x11, 0x02, 0x38, 0x31,
		0x03, 0x7E, 0x11, 0x02, 0x38, 0x30, 0x03, 0x7F,
		0x11, 0x02, 0x37, 0x46, 0x03, 0x80, 0x11, 0x02,
		0x37, 0x45, 0x03, 0x81, 0x11, 0x02, 0x37, 0x44,
		0x03, 0x82, 0x11, 0x02, 0x37, 0x43, 0x03, 0x83,
		0x11, 0x02, 0x37, 0x42, 0x03, 0x84, 0x11, 0x02,
		0x37, 0x41, 0x03, 0x85, 0x11, 0x02, 0x37, 0x39,
		0x03, 0x86, 0x11, 0x02, 0x37, 0x38, 0x03, 0x87,
		0x11, 0x02, 0x37, 0x37, 0x03, 0x88, 0x11, 0x02,
		0x37, 0x36, 0x03, 0x89, 0x11, 0x02, 0x37, 0x35,
		0x03, 0x8A, 0x11, 0x02, 0x37, 0x34, 0x03, 0x8B,
		0x11, 0x02, 0x37, 0x33, 0x03, 0x8C, 0x11, 0x02,
		0x37, 0x32, 0x03, 0x8D, 0x11, 0x02, 0x37, 0x31,
		0x03, 0x8E, 0x11, 0x02, 0x37, 0x30, 0x03, 0x8F,
		0x11, 0x02, 0x36, 0x46, 0x03, 0x90, 0x11, 0x02,
		0x36, 0x45, 0x03, 0x91, 0x11, 0x02, 0x36, 0x44,
		0x03, 0x92, 0x11, 0x02, 0x36, 0x43, 0x03, 0x93,
		0x11, 0x02, 0x36, 0x42, 0x03, 0x94, 0x11, 0x02,
		0x36, 0x41, 0x03, 0x95, 0x11, 0x02, 0x36, 0x39,
		0x03, 0x96, 0x11, 0x02, 0x36, 0x38, 0x03, 0x97,
		0x11, 0x02, 0x36, 0x37, 0x03, 0x98, 0x11, 0x02,
		0x36, 0x36, 0x03, 0x99, 0x11, 0x02, 0x36, 0x35,
		0x03, 0x9A, 0x11, 0x02, 0x36, 0x34, 0x03, 0x9B,
		0x11, 0x02, 0x36, 0x33, 0x03, 0x9C, 0x11, 0x02,
		0x36, 0x32, 0x03, 0x9D, 0x11, 0x02, 0x36, 0x31,
		0x03, 0x9E, 0x11, 0x02, 0x36, 0x30, 0x03, 0x9F,
		0x11, 0x02, 0x35, 0x46, 0x03, 0xA0, 0x11, 0x02,
		0x35, 0x45, 0x03, 0xA1, 0x11, 0x02, 0x35, 0x44,
		0x03, 0xA2, 0x11, 0x02, 0x35, 0x43, 0x03, 0xA3,
		0x11, 0x02, 0x35, 0x42, 0x03, 0xA4, 0x11, 0x02,
		0x35, 0x41, 0x03, 0xA5, 0x11, 0x02, 0x35, 0x39,
		0x03, 0xA6, 0x11, 0x02, 0x35, 0x38, 0x03, 0xA7,
		0x11, 0x02, 0x35, 0x37, 0x03, 0xA8, 0x11, 0x02,
		0x35, 0x36, 0x03, 0xA9, 0x11, 0x02, 0x35, 0x35,
		0x03, 0xAA, 0x11, 0x02, 0x35, 0x34, 0x03, 0xAB,
		0x11, 0x02, 0x35, 0x33, 0x03, 0xAC, 0x11, 0x02,
		0x35, 0x32, 0x03, 0xAD, 0x11, 0x02, 0x35, 0x31,
		0x03, 0xAE, 0x11, 0x02, 0x35, 0x30, 0x03, 0xAF,
		0x11, 0x02, 0x34, 0x46, 0x03, 0xB0, 0x11, 0x02,
		0x34, 0x45, 0x03, 0xB1, 0x11, 0x02, 0x34, 0x44,
		0x03, 0xB2, 0x11, 0x02, 0x34, 0x43, 0x03, 0xB3,
		0x11, 0x02, 0x34, 0x42, 0x03, 0xB4, 0x11, 0x02,
		0x34, 0x41, 0x03, 0xB5, 0x11, 0x02, 0x34, 0x39,
		0x03, 0xB6, 0x11, 0x02, 0x34, 0x38, 0x03, 0xB7,
		0x11, 0x02, 0x34, 0x37, 0x03, 0xB8, 0x11, 0x02,
		0x34, 0x36, 0x03, 0xB9, 0x11, 0x02, 0x34, 0x35,
		0x03, 0xBA, 0x11, 0x02, 0x34, 0x34, 0x03, 0xBB,
		0x11, 0x02, 0x34, 0x33, 0x03, 0xBC, 0x11, 0x02,
		0x34, 0x32, 0x03, 0xBD, 0x11, 0x02, 0x34, 0x31,
		0x03, 0xBE, 0x11, 0x02, 0x34, 0x30, 0x03, 0xBF,
		0x11, 0x02, 0x33, 0x46, 0x03, 0xC0, 0x11, 0x02,
		0x33, 0x45, 0x03, 0xC1, 0x11, 0x02, 0x33, 0x44,
		0x03, 0xC2, 0x11, 0x02, 0x33, 0x43, 0x03, 0xC3,
		0x11, 0x02, 0x33, 0x42, 0x03, 0xC4, 0x11, 0x02,
		0x33, 0x41, 0x03, 0xC5, 0x11, 0x02, 0x33, 0x39,
		0x03, 0xC6, 0x11, 0x02, 0x33, 0x38, 0x03, 0xC7,
		0x11, 0x02, 0x33, 0x37, 0x03, 0xC8, 0x11, 0x02,
		0x33, 0x36, 0x03, 0xC9, 0x11, 0x02, 0x33, 0x35,
		0x03, 0xCA, 0x11, 0x02, 0x33, 0x34, 0x03, 0xCB,
		0x11, 0x02, 0x33, 0x33, 0x03, 0xCC, 0x11, 0x02,
		0x33, 0x32, 0x03, 0xCD, 0x11, 0x02, 0x33, 0x31,
		0x03, 0xCE, 0x11, 0x02, 0x33, 0x30, 0x03, 0xCF,
		0x11, 0x02, 0x32, 0x46, 0x03, 0xD0, 0x11, 0x02,
		0x32, 0x45, 0x03, 0xD1, 0x11, 0x02, 0x32, 0x44,
		0x03, 0xD2, 0x11, 0x02, 0x32, 0x43, 0x03, 0xD3,
		0x11, 0x02, 0x32, 0x42, 0x03, 0xD4, 0x11, 0x02,
		0x32, 0x41, 0x03, 0xD5, 0x11, 0x02, 0x32, 0x39,
		0x03, 0xD6, 0x11, 0x02, 0x32, 0x38, 0x03, 0xD7,
		0x11, 0x02, 0x32, 0x37, 0x03, 0xD8, 0x11, 0x02,
		0x32, 0x36, 0x03, 0xD9, 0x11, 0x02, 0x32, 0x35,
		0x03, 0xDA, 0x11, 0x02, 0x32, 0x34, 0x03, 0xDB,
		0x11, 0x02, 0x32, 0x33, 0x03, 0xDC, 0x11, 0x02,
		0x32, 0x32, 0x03, 0xDD, 0x11, 0x02, 0x32, 0x31,
		0x03, 0xDE, 0x11, 0x02, 0x32, 0x30, 0x03, 0xDF,
		0x11, 0x02, 0x31, 0x46, 0x03, 0xE0, 0x11, 0x02,
		0x31, 0x45, 0x03, 0xE1, 0x11, 0x02, 0x31, 0x44,
		0x03, 0xE2, 0x11, 0x02, 0x31, 0x43, 0x03, 0xE3,
		0x11, 0x02, 0x31, 0x42, 0x03, 0xE4, 0x11, 0x02,
		0x31, 0x41, 0x03, 0xE5, 0x11, 0x02, 0x31, 0x39,
		0x03, 0xE6, 0x11, 0x02, 0x31, 0x38, 0x03, 0xE7,
		0x11, 0x02, 0x31, 0x37, 0x03, 0xE8, 0x11, 0x02,
		0x31, 0x36, 0x03, 0xE9, 0x11, 0x02, 0x31, 0x35,
		0x03, 0xEA, 0x11, 0x02, 0x31, 0x34, 0x03, 0xEB,
		0x11, 0x02, 0x31, 0x33, 0x03, 0xEC, 0x11, 0x02,
		0x31, 0x32, 0x03, 0xED, 0x11, 0x02, 0x31, 0x31,
		0x03, 0xEE, 0x11, 0x02, 0x31, 0x30, 0x03, 0xEF,
		0x11, 0x02, 0x30, 0x46, 0x03, 0xF0, 0x11, 0x02,
		0x30, 0x45, 0x03, 0xF1, 0x11, 0x02, 0x30, 0x44,
		0x03, 0xF2, 0x11, 0x02, 0x30, 0x43, 0x03, 0xF3,
		0x11, 0x02, 0x30, 0x42, 0x03, 0xF4, 0x11, 0x02,
		0x30, 0x41, 0x03, 0xF5, 0x11, 0x02, 0x30, 0x39,
		0x03, 0xF6, 0x11, 0x02, 0x30, 0x38, 0x03, 0xF7,
		0x11, 0x02, 0x30, 0x37, 0x03, 0xF8, 0x11, 0x02,
		0x30, 0x36, 0x03, 0xF9, 0x11, 0x02, 0x30, 0x35,
		0x03, 0xFA, 0x11, 0x02, 0x30, 0x34, 0x03, 0xFB,
		0x11, 0x02, 0x30, 0x33, 0x03, 0xFC, 0x11, 0x02,
		0x30, 0x32, 0x03, 0xFD, 0x11, 0x02, 0x30, 0x31,
		0x03, 0xFE, 0x11, 0x02, 0x30, 0x30, 0x03, 0xFF,
	}
	keys := []string{
		"FF", "FE", "FD", "FC", "FB", "FA", "F9", "F8",
		"F7", "F6", "F5", "F4", "F3", "F2", "F1", "F0",
		"EF", "EE", "ED", "EC", "EB", "EA", "E9", "E8",
		"E7", "E6", "E5", "E4", "E3", "E2", "E1", "E0",
		"DF", "DE", "DD", "DC", "DB", "DA", "D9", "D8",
		"D7", "D6", "D5", "D4", "D3", "D2", "D1", "D0",
		"CF", "CE", "CD", "CC", "CB", "CA", "C9", "C8",
		"C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0",
		"BF", "BE", "BD", "BC", "BB", "BA", "B9", "B8",
		"B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0",
		"AF", "AE", "AD", "AC", "AB", "AA", "A9", "A8",
		"A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0",
		"9F", "9E", "9D", "9C", "9B", "9A", "99", "98",
		"97", "96", "95", "94", "93", "92", "91", "90",
		"8F", "8E", "8D", "8C", "8B", "8A", "89", "88",
		"87", "86", "85", "84", "83", "82", "81", "80",
		"7F", "7E", "7D", "7C", "7B", "7A", "79", "78",
		"77", "76", "75", "74", "73", "72", "71", "70",
		"6F", "6E", "6D", "6C", "6B", "6A", "69", "68",
		"67", "66", "65", "64", "63", "62", "61", "60",
		"5F", "5E", "5D", "5C", "5B", "5A", "59", "58",
		"57", "56", "55", "54", "53", "52", "51", "50",
		"4F", "4E", "4D", "4C", "4B", "4A", "49", "48",
		"47", "46", "45", "44", "43", "42", "41", "40",
		"3F", "3E", "3D", "3C", "3B", "3A", "39", "38",
		"37", "36", "35", "34", "33", "32", "31", "30",
		"2F", "2E", "2D", "2C", "2B", "2A", "29", "28",
		"27", "26", "25", "24", "23", "22", "21", "20",
		"1F", "1E", "1D", "1C", "1B", "1A", "19", "18",
		"17", "16", "15", "14", "13", "12", "11", "10",
		"0F", "0E", "0D", "0C", "0B", "0A", "09", "08",
		"07", "06", "05", "04", "03", "02", "01", "00"}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &DictionaryTag{}, tag)
	assert.Equal(t, keys, tag.(*DictionaryTag).Map.Keys())
	for i, k := range keys {
		tv, ok = tag.(*DictionaryTag).Map.Get(k)
		assert.True(t, ok)
		assert.Equal(t, uint8(i), tv.(*UInt8Tag).Payload)
	}
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1E, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}

func TestStringDictionaryTagReference(t *testing.T) {

	serialized := []byte{
		0x1F, // ID
		0x01, // Size
		0x00, // Payload
	}
	r := bytes.NewReader(serialized)
	tag, err := ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &StringDictionaryTag{}, tag)
	assert.Equal(t, 0, tag.(*StringDictionaryTag).Map.Size())
	w := bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1F,       // ID
		0x05,       // Size
		0x01,       // Count
		0x11, 0x00, // Key 0
		0x11, 0x00, // Key 0
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &StringDictionaryTag{}, tag)
	assert.Equal(t, []string{""}, tag.(*StringDictionaryTag).Map.Keys())
	tv, ok := tag.(*StringDictionaryTag).Map.Get("")
	assert.True(t, ok)
	assert.Equal(t, "", tv)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1F,             // ID
		0x0D,             // Size
		0x02,             // Count
		0x11, 0x01, 0x31, // Key 0
		0x11, 0x01, 0x51, // Value 0
		0x11, 0x01, 0x30, // Key 1
		0x11, 0x01, 0x50, // Value 1
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &StringDictionaryTag{}, tag)
	assert.Equal(t, []string{"1", "0"}, tag.(*StringDictionaryTag).Map.Keys())
	tv, ok = tag.(*StringDictionaryTag).Map.Get("1")
	assert.True(t, ok)
	assert.Equal(t, "Q", tv)
	tv, ok = tag.(*StringDictionaryTag).Map.Get("0")
	assert.True(t, ok)
	assert.Equal(t, "P", tv)
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1F,             // ID
		0xF9, 0x07, 0x9C, // Size
		0xF8, 0x08, // Count
		0x11, 0x02, 0x46, 0x46, 0x11, 0x01, 0x30, 0x11,
		0x02, 0x46, 0x45, 0x11, 0x01, 0x31, 0x11, 0x02,
		0x46, 0x44, 0x11, 0x01, 0x32, 0x11, 0x02, 0x46,
		0x43, 0x11, 0x01, 0x33, 0x11, 0x02, 0x46, 0x42,
		0x11, 0x01, 0x34, 0x11, 0x02, 0x46, 0x41, 0x11,
		0x01, 0x35, 0x11, 0x02, 0x46, 0x39, 0x11, 0x01,
		0x36, 0x11, 0x02, 0x46, 0x38, 0x11, 0x01, 0x37,
		0x11, 0x02, 0x46, 0x37, 0x11, 0x01, 0x38, 0x11,
		0x02, 0x46, 0x36, 0x11, 0x01, 0x39, 0x11, 0x02,
		0x46, 0x35, 0x11, 0x02, 0x31, 0x30, 0x11, 0x02,
		0x46, 0x34, 0x11, 0x02, 0x31, 0x31, 0x11, 0x02,
		0x46, 0x33, 0x11, 0x02, 0x31, 0x32, 0x11, 0x02,
		0x46, 0x32, 0x11, 0x02, 0x31, 0x33, 0x11, 0x02,
		0x46, 0x31, 0x11, 0x02, 0x31, 0x34, 0x11, 0x02,
		0x46, 0x30, 0x11, 0x02, 0x31, 0x35, 0x11, 0x02,
		0x45, 0x46, 0x11, 0x02, 0x31, 0x36, 0x11, 0x02,
		0x45, 0x45, 0x11, 0x02, 0x31, 0x37, 0x11, 0x02,
		0x45, 0x44, 0x11, 0x02, 0x31, 0x38, 0x11, 0x02,
		0x45, 0x43, 0x11, 0x02, 0x31, 0x39, 0x11, 0x02,
		0x45, 0x42, 0x11, 0x02, 0x32, 0x30, 0x11, 0x02,
		0x45, 0x41, 0x11, 0x02, 0x32, 0x31, 0x11, 0x02,
		0x45, 0x39, 0x11, 0x02, 0x32, 0x32, 0x11, 0x02,
		0x45, 0x38, 0x11, 0x02, 0x32, 0x33, 0x11, 0x02,
		0x45, 0x37, 0x11, 0x02, 0x32, 0x34, 0x11, 0x02,
		0x45, 0x36, 0x11, 0x02, 0x32, 0x35, 0x11, 0x02,
		0x45, 0x35, 0x11, 0x02, 0x32, 0x36, 0x11, 0x02,
		0x45, 0x34, 0x11, 0x02, 0x32, 0x37, 0x11, 0x02,
		0x45, 0x33, 0x11, 0x02, 0x32, 0x38, 0x11, 0x02,
		0x45, 0x32, 0x11, 0x02, 0x32, 0x39, 0x11, 0x02,
		0x45, 0x31, 0x11, 0x02, 0x33, 0x30, 0x11, 0x02,
		0x45, 0x30, 0x11, 0x02, 0x33, 0x31, 0x11, 0x02,
		0x44, 0x46, 0x11, 0x02, 0x33, 0x32, 0x11, 0x02,
		0x44, 0x45, 0x11, 0x02, 0x33, 0x33, 0x11, 0x02,
		0x44, 0x44, 0x11, 0x02, 0x33, 0x34, 0x11, 0x02,
		0x44, 0x43, 0x11, 0x02, 0x33, 0x35, 0x11, 0x02,
		0x44, 0x42, 0x11, 0x02, 0x33, 0x36, 0x11, 0x02,
		0x44, 0x41, 0x11, 0x02, 0x33, 0x37, 0x11, 0x02,
		0x44, 0x39, 0x11, 0x02, 0x33, 0x38, 0x11, 0x02,
		0x44, 0x38, 0x11, 0x02, 0x33, 0x39, 0x11, 0x02,
		0x44, 0x37, 0x11, 0x02, 0x34, 0x30, 0x11, 0x02,
		0x44, 0x36, 0x11, 0x02, 0x34, 0x31, 0x11, 0x02,
		0x44, 0x35, 0x11, 0x02, 0x34, 0x32, 0x11, 0x02,
		0x44, 0x34, 0x11, 0x02, 0x34, 0x33, 0x11, 0x02,
		0x44, 0x33, 0x11, 0x02, 0x34, 0x34, 0x11, 0x02,
		0x44, 0x32, 0x11, 0x02, 0x34, 0x35, 0x11, 0x02,
		0x44, 0x31, 0x11, 0x02, 0x34, 0x36, 0x11, 0x02,
		0x44, 0x30, 0x11, 0x02, 0x34, 0x37, 0x11, 0x02,
		0x43, 0x46, 0x11, 0x02, 0x34, 0x38, 0x11, 0x02,
		0x43, 0x45, 0x11, 0x02, 0x34, 0x39, 0x11, 0x02,
		0x43, 0x44, 0x11, 0x02, 0x35, 0x30, 0x11, 0x02,
		0x43, 0x43, 0x11, 0x02, 0x35, 0x31, 0x11, 0x02,
		0x43, 0x42, 0x11, 0x02, 0x35, 0x32, 0x11, 0x02,
		0x43, 0x41, 0x11, 0x02, 0x35, 0x33, 0x11, 0x02,
		0x43, 0x39, 0x11, 0x02, 0x35, 0x34, 0x11, 0x02,
		0x43, 0x38, 0x11, 0x02, 0x35, 0x35, 0x11, 0x02,
		0x43, 0x37, 0x11, 0x02, 0x35, 0x36, 0x11, 0x02,
		0x43, 0x36, 0x11, 0x02, 0x35, 0x37, 0x11, 0x02,
		0x43, 0x35, 0x11, 0x02, 0x35, 0x38, 0x11, 0x02,
		0x43, 0x34, 0x11, 0x02, 0x35, 0x39, 0x11, 0x02,
		0x43, 0x33, 0x11, 0x02, 0x36, 0x30, 0x11, 0x02,
		0x43, 0x32, 0x11, 0x02, 0x36, 0x31, 0x11, 0x02,
		0x43, 0x31, 0x11, 0x02, 0x36, 0x32, 0x11, 0x02,
		0x43, 0x30, 0x11, 0x02, 0x36, 0x33, 0x11, 0x02,
		0x42, 0x46, 0x11, 0x02, 0x36, 0x34, 0x11, 0x02,
		0x42, 0x45, 0x11, 0x02, 0x36, 0x35, 0x11, 0x02,
		0x42, 0x44, 0x11, 0x02, 0x36, 0x36, 0x11, 0x02,
		0x42, 0x43, 0x11, 0x02, 0x36, 0x37, 0x11, 0x02,
		0x42, 0x42, 0x11, 0x02, 0x36, 0x38, 0x11, 0x02,
		0x42, 0x41, 0x11, 0x02, 0x36, 0x39, 0x11, 0x02,
		0x42, 0x39, 0x11, 0x02, 0x37, 0x30, 0x11, 0x02,
		0x42, 0x38, 0x11, 0x02, 0x37, 0x31, 0x11, 0x02,
		0x42, 0x37, 0x11, 0x02, 0x37, 0x32, 0x11, 0x02,
		0x42, 0x36, 0x11, 0x02, 0x37, 0x33, 0x11, 0x02,
		0x42, 0x35, 0x11, 0x02, 0x37, 0x34, 0x11, 0x02,
		0x42, 0x34, 0x11, 0x02, 0x37, 0x35, 0x11, 0x02,
		0x42, 0x33, 0x11, 0x02, 0x37, 0x36, 0x11, 0x02,
		0x42, 0x32, 0x11, 0x02, 0x37, 0x37, 0x11, 0x02,
		0x42, 0x31, 0x11, 0x02, 0x37, 0x38, 0x11, 0x02,
		0x42, 0x30, 0x11, 0x02, 0x37, 0x39, 0x11, 0x02,
		0x41, 0x46, 0x11, 0x02, 0x38, 0x30, 0x11, 0x02,
		0x41, 0x45, 0x11, 0x02, 0x38, 0x31, 0x11, 0x02,
		0x41, 0x44, 0x11, 0x02, 0x38, 0x32, 0x11, 0x02,
		0x41, 0x43, 0x11, 0x02, 0x38, 0x33, 0x11, 0x02,
		0x41, 0x42, 0x11, 0x02, 0x38, 0x34, 0x11, 0x02,
		0x41, 0x41, 0x11, 0x02, 0x38, 0x35, 0x11, 0x02,
		0x41, 0x39, 0x11, 0x02, 0x38, 0x36, 0x11, 0x02,
		0x41, 0x38, 0x11, 0x02, 0x38, 0x37, 0x11, 0x02,
		0x41, 0x37, 0x11, 0x02, 0x38, 0x38, 0x11, 0x02,
		0x41, 0x36, 0x11, 0x02, 0x38, 0x39, 0x11, 0x02,
		0x41, 0x35, 0x11, 0x02, 0x39, 0x30, 0x11, 0x02,
		0x41, 0x34, 0x11, 0x02, 0x39, 0x31, 0x11, 0x02,
		0x41, 0x33, 0x11, 0x02, 0x39, 0x32, 0x11, 0x02,
		0x41, 0x32, 0x11, 0x02, 0x39, 0x33, 0x11, 0x02,
		0x41, 0x31, 0x11, 0x02, 0x39, 0x34, 0x11, 0x02,
		0x41, 0x30, 0x11, 0x02, 0x39, 0x35, 0x11, 0x02,
		0x39, 0x46, 0x11, 0x02, 0x39, 0x36, 0x11, 0x02,
		0x39, 0x45, 0x11, 0x02, 0x39, 0x37, 0x11, 0x02,
		0x39, 0x44, 0x11, 0x02, 0x39, 0x38, 0x11, 0x02,
		0x39, 0x43, 0x11, 0x02, 0x39, 0x39, 0x11, 0x02,
		0x39, 0x42, 0x11, 0x03, 0x31, 0x30, 0x30, 0x11,
		0x02, 0x39, 0x41, 0x11, 0x03, 0x31, 0x30, 0x31,
		0x11, 0x02, 0x39, 0x39, 0x11, 0x03, 0x31, 0x30,
		0x32, 0x11, 0x02, 0x39, 0x38, 0x11, 0x03, 0x31,
		0x30, 0x33, 0x11, 0x02, 0x39, 0x37, 0x11, 0x03,
		0x31, 0x30, 0x34, 0x11, 0x02, 0x39, 0x36, 0x11,
		0x03, 0x31, 0x30, 0x35, 0x11, 0x02, 0x39, 0x35,
		0x11, 0x03, 0x31, 0x30, 0x36, 0x11, 0x02, 0x39,
		0x34, 0x11, 0x03, 0x31, 0x30, 0x37, 0x11, 0x02,
		0x39, 0x33, 0x11, 0x03, 0x31, 0x30, 0x38, 0x11,
		0x02, 0x39, 0x32, 0x11, 0x03, 0x31, 0x30, 0x39,
		0x11, 0x02, 0x39, 0x31, 0x11, 0x03, 0x31, 0x31,
		0x30, 0x11, 0x02, 0x39, 0x30, 0x11, 0x03, 0x31,
		0x31, 0x31, 0x11, 0x02, 0x38, 0x46, 0x11, 0x03,
		0x31, 0x31, 0x32, 0x11, 0x02, 0x38, 0x45, 0x11,
		0x03, 0x31, 0x31, 0x33, 0x11, 0x02, 0x38, 0x44,
		0x11, 0x03, 0x31, 0x31, 0x34, 0x11, 0x02, 0x38,
		0x43, 0x11, 0x03, 0x31, 0x31, 0x35, 0x11, 0x02,
		0x38, 0x42, 0x11, 0x03, 0x31, 0x31, 0x36, 0x11,
		0x02, 0x38, 0x41, 0x11, 0x03, 0x31, 0x31, 0x37,
		0x11, 0x02, 0x38, 0x39, 0x11, 0x03, 0x31, 0x31,
		0x38, 0x11, 0x02, 0x38, 0x38, 0x11, 0x03, 0x31,
		0x31, 0x39, 0x11, 0x02, 0x38, 0x37, 0x11, 0x03,
		0x31, 0x32, 0x30, 0x11, 0x02, 0x38, 0x36, 0x11,
		0x03, 0x31, 0x32, 0x31, 0x11, 0x02, 0x38, 0x35,
		0x11, 0x03, 0x31, 0x32, 0x32, 0x11, 0x02, 0x38,
		0x34, 0x11, 0x03, 0x31, 0x32, 0x33, 0x11, 0x02,
		0x38, 0x33, 0x11, 0x03, 0x31, 0x32, 0x34, 0x11,
		0x02, 0x38, 0x32, 0x11, 0x03, 0x31, 0x32, 0x35,
		0x11, 0x02, 0x38, 0x31, 0x11, 0x03, 0x31, 0x32,
		0x36, 0x11, 0x02, 0x38, 0x30, 0x11, 0x03, 0x31,
		0x32, 0x37, 0x11, 0x02, 0x37, 0x46, 0x11, 0x03,
		0x31, 0x32, 0x38, 0x11, 0x02, 0x37, 0x45, 0x11,
		0x03, 0x31, 0x32, 0x39, 0x11, 0x02, 0x37, 0x44,
		0x11, 0x03, 0x31, 0x33, 0x30, 0x11, 0x02, 0x37,
		0x43, 0x11, 0x03, 0x31, 0x33, 0x31, 0x11, 0x02,
		0x37, 0x42, 0x11, 0x03, 0x31, 0x33, 0x32, 0x11,
		0x02, 0x37, 0x41, 0x11, 0x03, 0x31, 0x33, 0x33,
		0x11, 0x02, 0x37, 0x39, 0x11, 0x03, 0x31, 0x33,
		0x34, 0x11, 0x02, 0x37, 0x38, 0x11, 0x03, 0x31,
		0x33, 0x35, 0x11, 0x02, 0x37, 0x37, 0x11, 0x03,
		0x31, 0x33, 0x36, 0x11, 0x02, 0x37, 0x36, 0x11,
		0x03, 0x31, 0x33, 0x37, 0x11, 0x02, 0x37, 0x35,
		0x11, 0x03, 0x31, 0x33, 0x38, 0x11, 0x02, 0x37,
		0x34, 0x11, 0x03, 0x31, 0x33, 0x39, 0x11, 0x02,
		0x37, 0x33, 0x11, 0x03, 0x31, 0x34, 0x30, 0x11,
		0x02, 0x37, 0x32, 0x11, 0x03, 0x31, 0x34, 0x31,
		0x11, 0x02, 0x37, 0x31, 0x11, 0x03, 0x31, 0x34,
		0x32, 0x11, 0x02, 0x37, 0x30, 0x11, 0x03, 0x31,
		0x34, 0x33, 0x11, 0x02, 0x36, 0x46, 0x11, 0x03,
		0x31, 0x34, 0x34, 0x11, 0x02, 0x36, 0x45, 0x11,
		0x03, 0x31, 0x34, 0x35, 0x11, 0x02, 0x36, 0x44,
		0x11, 0x03, 0x31, 0x34, 0x36, 0x11, 0x02, 0x36,
		0x43, 0x11, 0x03, 0x31, 0x34, 0x37, 0x11, 0x02,
		0x36, 0x42, 0x11, 0x03, 0x31, 0x34, 0x38, 0x11,
		0x02, 0x36, 0x41, 0x11, 0x03, 0x31, 0x34, 0x39,
		0x11, 0x02, 0x36, 0x39, 0x11, 0x03, 0x31, 0x35,
		0x30, 0x11, 0x02, 0x36, 0x38, 0x11, 0x03, 0x31,
		0x35, 0x31, 0x11, 0x02, 0x36, 0x37, 0x11, 0x03,
		0x31, 0x35, 0x32, 0x11, 0x02, 0x36, 0x36, 0x11,
		0x03, 0x31, 0x35, 0x33, 0x11, 0x02, 0x36, 0x35,
		0x11, 0x03, 0x31, 0x35, 0x34, 0x11, 0x02, 0x36,
		0x34, 0x11, 0x03, 0x31, 0x35, 0x35, 0x11, 0x02,
		0x36, 0x33, 0x11, 0x03, 0x31, 0x35, 0x36, 0x11,
		0x02, 0x36, 0x32, 0x11, 0x03, 0x31, 0x35, 0x37,
		0x11, 0x02, 0x36, 0x31, 0x11, 0x03, 0x31, 0x35,
		0x38, 0x11, 0x02, 0x36, 0x30, 0x11, 0x03, 0x31,
		0x35, 0x39, 0x11, 0x02, 0x35, 0x46, 0x11, 0x03,
		0x31, 0x36, 0x30, 0x11, 0x02, 0x35, 0x45, 0x11,
		0x03, 0x31, 0x36, 0x31, 0x11, 0x02, 0x35, 0x44,
		0x11, 0x03, 0x31, 0x36, 0x32, 0x11, 0x02, 0x35,
		0x43, 0x11, 0x03, 0x31, 0x36, 0x33, 0x11, 0x02,
		0x35, 0x42, 0x11, 0x03, 0x31, 0x36, 0x34, 0x11,
		0x02, 0x35, 0x41, 0x11, 0x03, 0x31, 0x36, 0x35,
		0x11, 0x02, 0x35, 0x39, 0x11, 0x03, 0x31, 0x36,
		0x36, 0x11, 0x02, 0x35, 0x38, 0x11, 0x03, 0x31,
		0x36, 0x37, 0x11, 0x02, 0x35, 0x37, 0x11, 0x03,
		0x31, 0x36, 0x38, 0x11, 0x02, 0x35, 0x36, 0x11,
		0x03, 0x31, 0x36, 0x39, 0x11, 0x02, 0x35, 0x35,
		0x11, 0x03, 0x31, 0x37, 0x30, 0x11, 0x02, 0x35,
		0x34, 0x11, 0x03, 0x31, 0x37, 0x31, 0x11, 0x02,
		0x35, 0x33, 0x11, 0x03, 0x31, 0x37, 0x32, 0x11,
		0x02, 0x35, 0x32, 0x11, 0x03, 0x31, 0x37, 0x33,
		0x11, 0x02, 0x35, 0x31, 0x11, 0x03, 0x31, 0x37,
		0x34, 0x11, 0x02, 0x35, 0x30, 0x11, 0x03, 0x31,
		0x37, 0x35, 0x11, 0x02, 0x34, 0x46, 0x11, 0x03,
		0x31, 0x37, 0x36, 0x11, 0x02, 0x34, 0x45, 0x11,
		0x03, 0x31, 0x37, 0x37, 0x11, 0x02, 0x34, 0x44,
		0x11, 0x03, 0x31, 0x37, 0x38, 0x11, 0x02, 0x34,
		0x43, 0x11, 0x03, 0x31, 0x37, 0x39, 0x11, 0x02,
		0x34, 0x42, 0x11, 0x03, 0x31, 0x38, 0x30, 0x11,
		0x02, 0x34, 0x41, 0x11, 0x03, 0x31, 0x38, 0x31,
		0x11, 0x02, 0x34, 0x39, 0x11, 0x03, 0x31, 0x38,
		0x32, 0x11, 0x02, 0x34, 0x38, 0x11, 0x03, 0x31,
		0x38, 0x33, 0x11, 0x02, 0x34, 0x37, 0x11, 0x03,
		0x31, 0x38, 0x34, 0x11, 0x02, 0x34, 0x36, 0x11,
		0x03, 0x31, 0x38, 0x35, 0x11, 0x02, 0x34, 0x35,
		0x11, 0x03, 0x31, 0x38, 0x36, 0x11, 0x02, 0x34,
		0x34, 0x11, 0x03, 0x31, 0x38, 0x37, 0x11, 0x02,
		0x34, 0x33, 0x11, 0x03, 0x31, 0x38, 0x38, 0x11,
		0x02, 0x34, 0x32, 0x11, 0x03, 0x31, 0x38, 0x39,
		0x11, 0x02, 0x34, 0x31, 0x11, 0x03, 0x31, 0x39,
		0x30, 0x11, 0x02, 0x34, 0x30, 0x11, 0x03, 0x31,
		0x39, 0x31, 0x11, 0x02, 0x33, 0x46, 0x11, 0x03,
		0x31, 0x39, 0x32, 0x11, 0x02, 0x33, 0x45, 0x11,
		0x03, 0x31, 0x39, 0x33, 0x11, 0x02, 0x33, 0x44,
		0x11, 0x03, 0x31, 0x39, 0x34, 0x11, 0x02, 0x33,
		0x43, 0x11, 0x03, 0x31, 0x39, 0x35, 0x11, 0x02,
		0x33, 0x42, 0x11, 0x03, 0x31, 0x39, 0x36, 0x11,
		0x02, 0x33, 0x41, 0x11, 0x03, 0x31, 0x39, 0x37,
		0x11, 0x02, 0x33, 0x39, 0x11, 0x03, 0x31, 0x39,
		0x38, 0x11, 0x02, 0x33, 0x38, 0x11, 0x03, 0x31,
		0x39, 0x39, 0x11, 0x02, 0x33, 0x37, 0x11, 0x03,
		0x32, 0x30, 0x30, 0x11, 0x02, 0x33, 0x36, 0x11,
		0x03, 0x32, 0x30, 0x31, 0x11, 0x02, 0x33, 0x35,
		0x11, 0x03, 0x32, 0x30, 0x32, 0x11, 0x02, 0x33,
		0x34, 0x11, 0x03, 0x32, 0x30, 0x33, 0x11, 0x02,
		0x33, 0x33, 0x11, 0x03, 0x32, 0x30, 0x34, 0x11,
		0x02, 0x33, 0x32, 0x11, 0x03, 0x32, 0x30, 0x35,
		0x11, 0x02, 0x33, 0x31, 0x11, 0x03, 0x32, 0x30,
		0x36, 0x11, 0x02, 0x33, 0x30, 0x11, 0x03, 0x32,
		0x30, 0x37, 0x11, 0x02, 0x32, 0x46, 0x11, 0x03,
		0x32, 0x30, 0x38, 0x11, 0x02, 0x32, 0x45, 0x11,
		0x03, 0x32, 0x30, 0x39, 0x11, 0x02, 0x32, 0x44,
		0x11, 0x03, 0x32, 0x31, 0x30, 0x11, 0x02, 0x32,
		0x43, 0x11, 0x03, 0x32, 0x31, 0x31, 0x11, 0x02,
		0x32, 0x42, 0x11, 0x03, 0x32, 0x31, 0x32, 0x11,
		0x02, 0x32, 0x41, 0x11, 0x03, 0x32, 0x31, 0x33,
		0x11, 0x02, 0x32, 0x39, 0x11, 0x03, 0x32, 0x31,
		0x34, 0x11, 0x02, 0x32, 0x38, 0x11, 0x03, 0x32,
		0x31, 0x35, 0x11, 0x02, 0x32, 0x37, 0x11, 0x03,
		0x32, 0x31, 0x36, 0x11, 0x02, 0x32, 0x36, 0x11,
		0x03, 0x32, 0x31, 0x37, 0x11, 0x02, 0x32, 0x35,
		0x11, 0x03, 0x32, 0x31, 0x38, 0x11, 0x02, 0x32,
		0x34, 0x11, 0x03, 0x32, 0x31, 0x39, 0x11, 0x02,
		0x32, 0x33, 0x11, 0x03, 0x32, 0x32, 0x30, 0x11,
		0x02, 0x32, 0x32, 0x11, 0x03, 0x32, 0x32, 0x31,
		0x11, 0x02, 0x32, 0x31, 0x11, 0x03, 0x32, 0x32,
		0x32, 0x11, 0x02, 0x32, 0x30, 0x11, 0x03, 0x32,
		0x32, 0x33, 0x11, 0x02, 0x31, 0x46, 0x11, 0x03,
		0x32, 0x32, 0x34, 0x11, 0x02, 0x31, 0x45, 0x11,
		0x03, 0x32, 0x32, 0x35, 0x11, 0x02, 0x31, 0x44,
		0x11, 0x03, 0x32, 0x32, 0x36, 0x11, 0x02, 0x31,
		0x43, 0x11, 0x03, 0x32, 0x32, 0x37, 0x11, 0x02,
		0x31, 0x42, 0x11, 0x03, 0x32, 0x32, 0x38, 0x11,
		0x02, 0x31, 0x41, 0x11, 0x03, 0x32, 0x32, 0x39,
		0x11, 0x02, 0x31, 0x39, 0x11, 0x03, 0x32, 0x33,
		0x30, 0x11, 0x02, 0x31, 0x38, 0x11, 0x03, 0x32,
		0x33, 0x31, 0x11, 0x02, 0x31, 0x37, 0x11, 0x03,
		0x32, 0x33, 0x32, 0x11, 0x02, 0x31, 0x36, 0x11,
		0x03, 0x32, 0x33, 0x33, 0x11, 0x02, 0x31, 0x35,
		0x11, 0x03, 0x32, 0x33, 0x34, 0x11, 0x02, 0x31,
		0x34, 0x11, 0x03, 0x32, 0x33, 0x35, 0x11, 0x02,
		0x31, 0x33, 0x11, 0x03, 0x32, 0x33, 0x36, 0x11,
		0x02, 0x31, 0x32, 0x11, 0x03, 0x32, 0x33, 0x37,
		0x11, 0x02, 0x31, 0x31, 0x11, 0x03, 0x32, 0x33,
		0x38, 0x11, 0x02, 0x31, 0x30, 0x11, 0x03, 0x32,
		0x33, 0x39, 0x11, 0x02, 0x30, 0x46, 0x11, 0x03,
		0x32, 0x34, 0x30, 0x11, 0x02, 0x30, 0x45, 0x11,
		0x03, 0x32, 0x34, 0x31, 0x11, 0x02, 0x30, 0x44,
		0x11, 0x03, 0x32, 0x34, 0x32, 0x11, 0x02, 0x30,
		0x43, 0x11, 0x03, 0x32, 0x34, 0x33, 0x11, 0x02,
		0x30, 0x42, 0x11, 0x03, 0x32, 0x34, 0x34, 0x11,
		0x02, 0x30, 0x41, 0x11, 0x03, 0x32, 0x34, 0x35,
		0x11, 0x02, 0x30, 0x39, 0x11, 0x03, 0x32, 0x34,
		0x36, 0x11, 0x02, 0x30, 0x38, 0x11, 0x03, 0x32,
		0x34, 0x37, 0x11, 0x02, 0x30, 0x37, 0x11, 0x03,
		0x32, 0x34, 0x38, 0x11, 0x02, 0x30, 0x36, 0x11,
		0x03, 0x32, 0x34, 0x39, 0x11, 0x02, 0x30, 0x35,
		0x11, 0x03, 0x32, 0x35, 0x30, 0x11, 0x02, 0x30,
		0x34, 0x11, 0x03, 0x32, 0x35, 0x31, 0x11, 0x02,
		0x30, 0x33, 0x11, 0x03, 0x32, 0x35, 0x32, 0x11,
		0x02, 0x30, 0x32, 0x11, 0x03, 0x32, 0x35, 0x33,
		0x11, 0x02, 0x30, 0x31, 0x11, 0x03, 0x32, 0x35,
		0x34, 0x11, 0x02, 0x30, 0x30, 0x11, 0x03, 0x32,
		0x35, 0x35,
	}
	keys := []string{
		"FF", "FE", "FD", "FC", "FB", "FA", "F9", "F8",
		"F7", "F6", "F5", "F4", "F3", "F2", "F1", "F0",
		"EF", "EE", "ED", "EC", "EB", "EA", "E9", "E8",
		"E7", "E6", "E5", "E4", "E3", "E2", "E1", "E0",
		"DF", "DE", "DD", "DC", "DB", "DA", "D9", "D8",
		"D7", "D6", "D5", "D4", "D3", "D2", "D1", "D0",
		"CF", "CE", "CD", "CC", "CB", "CA", "C9", "C8",
		"C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0",
		"BF", "BE", "BD", "BC", "BB", "BA", "B9", "B8",
		"B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0",
		"AF", "AE", "AD", "AC", "AB", "AA", "A9", "A8",
		"A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0",
		"9F", "9E", "9D", "9C", "9B", "9A", "99", "98",
		"97", "96", "95", "94", "93", "92", "91", "90",
		"8F", "8E", "8D", "8C", "8B", "8A", "89", "88",
		"87", "86", "85", "84", "83", "82", "81", "80",
		"7F", "7E", "7D", "7C", "7B", "7A", "79", "78",
		"77", "76", "75", "74", "73", "72", "71", "70",
		"6F", "6E", "6D", "6C", "6B", "6A", "69", "68",
		"67", "66", "65", "64", "63", "62", "61", "60",
		"5F", "5E", "5D", "5C", "5B", "5A", "59", "58",
		"57", "56", "55", "54", "53", "52", "51", "50",
		"4F", "4E", "4D", "4C", "4B", "4A", "49", "48",
		"47", "46", "45", "44", "43", "42", "41", "40",
		"3F", "3E", "3D", "3C", "3B", "3A", "39", "38",
		"37", "36", "35", "34", "33", "32", "31", "30",
		"2F", "2E", "2D", "2C", "2B", "2A", "29", "28",
		"27", "26", "25", "24", "23", "22", "21", "20",
		"1F", "1E", "1D", "1C", "1B", "1A", "19", "18",
		"17", "16", "15", "14", "13", "12", "11", "10",
		"0F", "0E", "0D", "0C", "0B", "0A", "09", "08",
		"07", "06", "05", "04", "03", "02", "01", "00"}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Nil(t, err)
	assert.Equal(t, IL_STRING_DICTIONARY_TAG_ID, tag.Id())
	assert.IsType(t, &StringDictionaryTag{}, tag)
	assert.Equal(t, keys, tag.(*StringDictionaryTag).Map.Keys())
	for i, k := range keys {
		tv, ok := tag.(*StringDictionaryTag).Map.Get(k)
		assert.True(t, ok)
		assert.Equal(t, fmt.Sprintf("%d", i), tv)
	}
	w = bytes.NewBuffer([]byte{})
	assert.Nil(t, ILTagSeralize(tag, w))
	assert.Equal(t, serialized, w.Bytes())

	serialized = []byte{
		0x1F, // ID
		0x00, // Size
	}
	r = bytes.NewReader(serialized)
	tag, err = ILTagDeserialize(testTagFactory, r)
	assert.Error(t, err)
	assert.Nil(t, tag)
}
